{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> Introspect Python type annotation, with ease.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install typingref\n\n---&gt; 100%\n</code></pre>"},{"location":"#sample-usage","title":"Sample Usage:","text":"<pre><code>from typingref import TypeHinter\nfrom typing import Union\n\n\nclass MyType:\n    ...\n\n\ndef foo(p: Union[int, str, float]) -&gt; MyType:\n    ...\n\n\np_type = TypeHinter.from_annotation(foo.__annotations__['p'])\n\nif p_type.is_union():\n    for t in p_type.of_type:\n        ...\n\nassert Union[int, str, float] == TypeHinter.as_annotation()\n</code></pre>"},{"location":"reference/","title":"API","text":"Source code in <code>typingref/core.py</code> <pre><code>class TypeHinter:\n    def __init__(\n        self,\n        type: Any,\n        of_type: tuple[\"TypeHinter\", ...] = (),\n    ):\n        self.type = type\n        self.of_type = of_type\n\n    def __eq__(self, other) -&gt; bool:\n        if not isinstance(other, TypeHinter):\n            return False\n\n        if not self.type == other.type:\n            return False\n\n        return all(child == other.of_type[count] for count, child in enumerate(self.of_type))\n\n    @classmethod\n    def from_string(cls, tp: str, ns: dict) -&gt; \"TypeHinter\":\n        from typing import List, Union, Dict, Optional, Any, Type, get_type_hints  # noqa\n\n        ns = ns.copy()\n        ns.update(locals())\n\n        def tmp(t: tp):  # type: ignore\n            ...  # pragma: no cover\n\n        annotation = get_type_hints(tmp, localns=ns, globalns=globals())[\"t\"]\n\n        return cls.from_annotation(annotation)\n\n    @classmethod\n    def from_annotation(cls, tp: Any, ns: Optional[dict] = None) -&gt; \"TypeHinter\":\n        # future annotation\n        ns = ns if ns else {}\n        if isinstance(tp, str):\n            return TypeHinter.from_string(tp, ns)\n        if isinstance(tp, ForwardRef):\n            return TypeHinter.from_string(tp.__forward_arg__, ns)\n        if args := get_args(tp):\n            # handle optional\n            if type(None) in args:\n                # optional union, 2 is default for optionals\n                if len(args) &gt; 2:\n                    return cls(\n                        type=Optional,\n                        of_type=(\n                            cls(\n                                type=Union,\n                                of_type=tuple(\n                                    cls.from_annotation(arg, ns)\n                                    for arg in args\n                                    if arg is not type(None)\n                                ),\n                            ),\n                        ),\n                    )\n                return cls(type=Optional, of_type=(cls.from_annotation(args[0], ns),))\n            new_args: list[TypeHinter] = []\n            for arg in args:\n                new_args.append(cls.from_annotation(arg, ns))\n\n            return cls(type=get_origin(tp), of_type=tuple(new_args))  # type: ignore\n        return cls(type=tp)\n\n    def as_annotation(self, object_map: Optional[dict[str, Any]] = None) -&gt; Any:\n        if self.type is str:\n            return self.type\n        # eval forward refs\n        if isinstance(self.type, str):\n            assert object_map, \"can't evaluate forward refs without object_map.\"\n            self.type = object_map[self.type]\n\n        if builder := getattr(\n            self.type,\n            \"__class_getitem__\",\n            getattr(self.type, \"__getitem__\", None),\n        ):\n            if self.is_union():\n                return builder(tuple(arg.as_annotation(object_map) for arg in self.of_type))\n            return builder(self.of_type[0].as_annotation(object_map))\n        return self.type\n\n    def stringify(self) -&gt; str:\n        annot = self.as_annotation()\n        if inspect.isclass(annot) and not hasattr(annot, \"__origin__\"):\n            return annot.__name__\n\n        return str(annot).replace(\"typing.\", \"\").replace(\"qtgql.codegen.utils.\", \"\")\n\n    def is_union(self) -&gt; bool:\n        return self.type is Union\n\n    def is_optional(self) -&gt; bool:\n        return self.type in (Optional, type(Optional))\n\n    def is_list(self) -&gt; bool:\n        return self.type in (list, List)\n\n    @classmethod\n    def strip_optionals(cls, inst: \"TypeHinter\") -&gt; \"TypeHinter\":\n        th = inst\n        if inst.is_optional():\n            th = inst.of_type[0]\n\n        return cls(type=th.type, of_type=tuple(cls.strip_optionals(tp) for tp in th.of_type))\n\n    def __repr__(self):  # pragma: no cover\n        if self.of_type:\n            return f\"{self.type}[{', '.join([repr(t) for t in self.of_type])}]]\"\n        return f\"{self.type}\"\n</code></pre>"}]}